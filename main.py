# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DCW5qWYxu0-B9KK7XVIh-RfannlWkBFY
"""

import numpy as np
import matplotlib.pyplot as plt
import streamlit as st


# -----------------------------
# Modelo: Cobb-Douglas
# u(x1,x2) = x1^alpha * x2^(1-alpha)
# Demanda marshalliana:
# x1* = alpha * m / p1
# x2* = (1-alpha) * m / p2
# -----------------------------
def cobb_douglas_demands(m: float, p1: float, p2: float, alpha: float):
    x1 = alpha * m / p1
    x2 = (1.0 - alpha) * m / p2
    return x1, x2


def cobb_douglas_utility(x1, x2, alpha: float):
    x1 = np.maximum(x1, 1e-12)
    x2 = np.maximum(x2, 1e-12)
    return (x1 ** alpha) * (x2 ** (1.0 - alpha))


def mrs_cobb_douglas(x1: float, x2: float, alpha: float):
    # MRS = MU1/MU2 = (alpha/(1-alpha)) * (x2/x1)
    return (alpha / (1.0 - alpha)) * (x2 / x1)


def plot_choice(m: float, p1: float, p2: float, alpha: float, show_contours: bool):
    x1_star, x2_star = cobb_douglas_demands(m, p1, p2, alpha)
    u_star = cobb_douglas_utility(x1_star, x2_star, alpha)

    # Rango para el gráfico en (x1, x2)
    x1_max = max(1.0, (m / p1) * 1.15)
    x2_max = max(1.0, (m / p2) * 1.15)

    x1 = np.linspace(0, x1_max, 400)
    x2_budget = (m - p1 * x1) / p2
    x2_budget = np.clip(x2_budget, 0, None)

    fig = plt.figure(figsize=(7.8, 5.6))
    ax = fig.add_subplot(111)

    # Recta presupuestaria
    ax.plot(x1, x2_budget, label="Recta presupuestaria")

    # Óptimo
    ax.scatter([x1_star], [x2_star], s=70, label=f"Óptimo (x1*, x2*) = ({x1_star:.2f}, {x2_star:.2f})")

    # Curvas de indiferencia alrededor de U*
    if show_contours:
        gx1 = np.linspace(1e-6, x1_max, 220)
        gx2 = np.linspace(1e-6, x2_max, 220)
        X1, X2 = np.meshgrid(gx1, gx2)
        U = cobb_douglas_utility(X1, X2, alpha)
        levels = np.linspace(0.55 * u_star, 1.45 * u_star, 7)
        ax.contour(X1, X2, U, levels=levels)

    ax.set_xlim(0, x1_max)
    ax.set_ylim(0, x2_max)
    ax.set_xlabel("Cantidad x1")
    ax.set_ylabel("Cantidad x2")
    ax.set_title("Decisión del consumidor: presupuesto + óptimo Cobb-Douglas")
    ax.legend()
    ax.grid(True, alpha=0.25)

    return fig, x1_star, x2_star, u_star


def plot_demand_x1_of_p1(m: float, p1: float, p2: float, alpha: float, pmin: float, pmax: float, n: int):
    pgrid = np.linspace(pmin, pmax, n)
    x1_vals = alpha * m / pgrid

    fig = plt.figure(figsize=(7.8, 4.8))
    ax = fig.add_subplot(111)
    ax.plot(pgrid, x1_vals, label="x1(p1) = α m / p1")
    ax.scatter([p1], [alpha * m / p1], s=60, label="Precio actual")
    ax.set_xlabel("p1")
    ax.set_ylabel("x1 demandada")
    ax.set_title("Demanda Marshalliana de x1 al variar p1 (m y p2 fijos)")
    ax.legend()
    ax.grid(True, alpha=0.25)
    return fig


def plot_demand_x2_of_p2(m: float, p1: float, p2: float, alpha: float, pmin: float, pmax: float, n: int):
    pgrid = np.linspace(pmin, pmax, n)
    x2_vals = (1.0 - alpha) * m / pgrid

    fig = plt.figure(figsize=(7.8, 4.8))
    ax = fig.add_subplot(111)
    ax.plot(pgrid, x2_vals, label="x2(p2) = (1-α) m / p2")
    ax.scatter([p2], [(1.0 - alpha) * m / p2], s=60, label="Precio actual")
    ax.set_xlabel("p2")
    ax.set_ylabel("x2 demandada")
    ax.set_title("Demanda Marshalliana de x2 al variar p2 (m y p1 fijos)")
    ax.legend()
    ax.grid(True, alpha=0.25)
    return fig


# -----------------------------
# Streamlit App
# -----------------------------
st.set_page_config(page_title="Cobb-Douglas: Demanda Marshalliana", layout="wide")

st.title("Cobb-Douglas: decisión del consumidor y demandas marshallianas")
st.markdown(
    r"""
Esta app muestra cómo un consumidor con preferencias Cobb-Douglas
\[
u(x_1,x_2)=x_1^{\alpha}x_2^{\,1-\alpha}
\]
elige \((x_1^\*,x_2^\*)\) al maximizar utilidad sujeto a
\[
p_1x_1 + p_2x_2 \le m.
\]
"""
)

with st.sidebar:
    st.header("Parámetros")
    m = st.slider("Ingreso (m)", min_value=1.0, max_value=500.0, value=100.0, step=1.0)
    p1 = st.slider("Precio (p1)", min_value=0.2, max_value=50.0, value=5.0, step=0.1)
    p2 = st.slider("Precio (p2)", min_value=0.2, max_value=50.0, value=5.0, step=0.1)
    alpha = st.slider("Preferencia α (peso en x1)", min_value=0.05, max_value=0.95, value=0.5, step=0.05)

    st.divider()
    st.subheader("Gráficas")
    show_contours = st.checkbox("Mostrar curvas de indiferencia", value=True)
    show_demands = st.checkbox("Mostrar curvas de demanda (ceteris paribus)", value=True)

    st.divider()
    st.subheader("Rango de precios (para demandas)")
    pmin = st.slider("Precio mínimo", min_value=0.2, max_value=10.0, value=0.5, step=0.1)
    pmax = st.slider("Precio máximo", min_value=10.0, max_value=80.0, value=20.0, step=1.0)
    ngrid = st.slider("Resolución", min_value=30, max_value=250, value=90, step=10)

# Cálculos principales
x1_star, x2_star = cobb_douglas_demands(m, p1, p2, alpha)
e1 = p1 * x1_star
e2 = p2 * x2_star
u_star = cobb_douglas_utility(x1_star, x2_star, alpha)

mrs_star = mrs_cobb_douglas(x1_star, x2_star, alpha)
price_ratio = p1 / p2

# Bloque “decisión” muy explícito
st.subheader("La decisión del consumidor (lo esencial)")
st.markdown(
    rf"""
**Regla de gasto Cobb-Douglas (clave didáctica):**
- Gasta una fracción **α** del ingreso en el bien 1 y **(1−α)** en el bien 2:
\[
p_1x_1^\*=\alpha m,\qquad p_2x_2^\*=(1-\alpha)m.
\]

**Por tanto, la canasta óptima es:**
\[
x_1^\*=\frac{{\alpha m}}{{p_1}},\qquad x_2^\*=\frac{{(1-\alpha)m}}{{p_2}}.
\]
"""
)

colA, colB, colC, colD = st.columns(4)
colA.metric("x1*", f"{x1_star:.4f}")
colB.metric("x2*", f"{x2_star:.4f}")
colC.metric("Gasto en bien 1 (p1·x1*)", f"{e1:.2f}")
colD.metric("Gasto en bien 2 (p2·x2*)", f"{e2:.2f}")

st.markdown(
    rf"""
**Chequeo de óptimo interior (condición de tangencia):**
En Cobb-Douglas, en el óptimo interior se cumple \(\text{{MRS}}=p_1/p_2\).
Aquí:
- \(\text{{MRS}}(x^\*) = \frac{{\alpha}}{{1-\alpha}}\cdot\frac{{x_2^\*}}{{x_1^\*}} = {mrs_star:.4f}\)
- \(\frac{{p_1}}{{p_2}} = {price_ratio:.4f}\)

(Deberían coincidir salvo redondeo.)
"""
)

# Gráfico de elección
st.subheader("Visualización del óptimo en el plano (x1, x2)")
fig_choice, _, _, _ = plot_choice(m, p1, p2, alpha, show_contours=show_contours)
st.pyplot(fig_choice)

# Demandas (ceteris paribus)
if show_demands:
    st.subheader("Demandas Marshallianas como ‘registro de óptimos’ (ceteris paribus)")
    st.markdown(
        r"""
Aquí se varía un precio manteniendo lo demás fijo.
Como \(x_1^\*=\alpha m/p_1\), al subir \(p_1\) cae \(x_1\) de forma hiperbólica.
Análogo para \(x_2^\*=(1-\alpha)m/p_2\).
"""
    )

    col1, col2 = st.columns(2)
    with col1:
        fig_x1 = plot_demand_x1_of_p1(m, p1, p2, alpha, pmin=pmin, pmax=pmax, n=ngrid)
        st.pyplot(fig_x1)
    with col2:
        fig_x2 = plot_demand_x2_of_p2(m, p1, p2, alpha, pmin=pmin, pmax=pmax, n=ngrid)
        st.pyplot(fig_x2)

st.caption("Tip didáctico: fija α y cambia m → verás que ambas cantidades crecen proporcionalmente; fija m y cambia p1 → sólo cae x1*.")